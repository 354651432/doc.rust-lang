#    -*- mode: org -*-


Archived entries from file /home/aniki/demo/doc-rust/19.org


* 解引用一个原始指针
:PROPERTIES:
:ARCHIVE_TIME: 2022-03-02 三 14:16
:ARCHIVE_FILE: ~/demo/doc-rust/19.org
:ARCHIVE_OLPATH: 高级特性/不安全rust
:ARCHIVE_CATEGORY: 19
:END:
在第4章, 在"悬挂指针"一节里, 我们提到编译器确保指针总是有效. 不安全rust有两上新的叫原始指针的类型,和引用相似. 有使用引用一样, 原始指针可以是只读的或者是读写的然后分别可以被写为 *const T和 *mut T. 星号不是解引用操作; 这是类型名称的一部分. 在原始指针的上下文里, 只写意味着那个指针不可以直接赋值给后面的解引用.

引用和智能指针, 原始的指针的区别:
+ 使用只读或者读写指针或者多个指针指向相同地方都允许忽略借用规则
+ 不能保证指向的内存合法
+ 都可以允许为空
+ 不实现任何的自动清理
  选择退出rust有的这些强制规则,  你可以以更好的性能作为交换或者和其它或者rust的守卫不用就的地方的硬件交互的能力放弃这些安全的保证.

  代码 19-1 展示了如何创建一个只读的和一个读写的来自引用的原始的指针.
#+begin_src rust
fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
}
#+end_src
代码 19-1: 创建从引用来的原始指针

注意这个代码里我们没有包括unsafe关键字. 我们在安全代码里创建原始指针; 我们只是不能在不安全块外面解引用原始指针, 如果看到的一点点.

我们使用 as 转化一个只读和一个读写引用来它们的相应的原始指针类型创建了原始指针. 因为我们直接地从引用保证到有效创建它们, 我们知道这些特定的原始指针是有效的, 但我们不能做只有任何原始指针的假设.

下面, 我们创建我们不能如此肯定这些有效性的原始指针. 代码19-2 展示了如何创建原始指针到一个内存的随意位置. 尝试使用随意位置是末定义的: 在那个地址可能有数据或者没有, 编译器可能优化代码让这里没的内存访问, 或者程序可能伴随着段错误出错. 通常, 没有好的原因像这样写代码, 但它是可能的.

#+begin_src rust
fn main() {
    let address = 0x012345usize;
    let r = address as *const i32;
}
#+end_src
代码 19-2: 创建一个原始指针到一个随意的内存地址

回顾我们在安全代码里创建原始指针, 但我们不能解引用原始指针和读被指向的数据. 在代双19-3里, 我们在一个需要unsafe块的原始指针上使用解引用操作 *.

#+begin_src rust
fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
}
#+end_src
代码 19-3: 使用unsafe块解引用原始指针

创建一个无害的指针; 只有当我们尝试访问它可能指向我们可能伴随一个非法值悬挂的值.

也注意在代码19-1和19-3, 我们创建的都指向相同内存的 *const i32和 *mut i32原始指针, num被保存了. 
