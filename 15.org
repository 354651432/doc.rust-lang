* 智能指针
对于一个在内存里包含一个地址的变量一个指针是一个常规的概念. 这个地址引用到的, 或者是"指向的"一些其它数据. 在rust里最常见的指针的种类是一个引用, 你在第4章已经学过的. 引用通过&符号指明然后借用它们指向的值. 它们除了引用数据没有任何特别的能力. 它们也没有任何负载就是我们经常使用的指针的种类.

智能指针, 换种方式, 是不只表现得像一个指针也有额外原始数据和能力的数据结构. 智能指针的概念对rust不唯一: 智能指针源自于C++在其它语言里面也存在. 在rust里, 不同的智能指针被定义在标准库里提供超过引用的功能. 在这一章我们将探索的一个例子是引用计数智能指针类型. 这种指针通过跟踪所有者的数量,当没有所有者存在时,消除数据让你可以有数据的多个所有者.

在rust里, 使用所有者有借用的概念, 引用和智能指针一个额外的区别是引用就是只借用数据的指针; 相比之下,在很多情况下, 智能指针拥有它们指向的数据.

在本书我们已经遇到了一些智能指针, 比如在第8章的String和Vec<T>, 虽然那时我们没有称它们为智能指针. 这两种类型作为智能指针因为它们有相同的内存而且允许你维护它. 它们也有原始数据(比如容量)和额外的承载或者保证(比如String确保它的数据将一直是有效的UTF-8).

智能指针通常实现为结构体. 从一个原始结构体区别一个智能指针的特征是智能指针实现 Deref和Drop特征. Deref 特征允许一个智能指针结构体的实例像一个引用所以你可以写与其它引用或者智能指针工作的代码. Drop特征允许你自定义当智能指针的一个实例超出作用域运行时的代码. 在本章, 我们将讨论这两特征然后展示为它们为什么对智能指针如此重要.

在rust里给定的智能指针模式是频繁使用的通用设计模式, 本章不覆盖所有已经存在的智能指针. 许多库有它们自己的智能指针, 而且甚至你也可以写你自己的. 我们将覆盖在标准库里最常见的智能指针:

+ Box<T> 在堆上分配的值
+ Rc<T> 可以有多个所有者的引用计数类型
+ Ref<T> 和RefMut<T> ,通过RefCell<t>访问, 运行时而不是编译时强制借用规则的一个类型

额外地, 我们将覆盖内部可变的模式一个不可变类型暴露一个API给一个内部值, 我们也将讨论引用循环: 它们如何可能泄漏内存和如何预防它们.

让我们深入!
